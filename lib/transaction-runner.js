// Generated by CoffeeScript 1.6.3
var TransactionRunner, addHooks, advisable, async, flattenHeaders, gavel, html, http, https, logger, os, packageConfig, path, sortTransactions, url,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

http = require('http');

https = require('https');

html = require('html');

url = require('url');

path = require('path');

os = require('os');

gavel = require('gavel');

advisable = require('advisable');

async = require('async');

flattenHeaders = require('./flatten-headers');

addHooks = require('./add-hooks');

sortTransactions = require('./sort-transactions');

packageConfig = require('./../package.json');

logger = require('./logger');

String.prototype.startsWith = function(str) {
  return this.slice(0, str.length) === str;
};

TransactionRunner = (function() {
  function TransactionRunner(configuration) {
    this.configuration = configuration;
    this.executeTransaction = __bind(this.executeTransaction, this);
    this.configureTransaction = __bind(this.configureTransaction, this);
    advisable.async.call(TransactionRunner.prototype);
    addHooks(this, {});
  }

  TransactionRunner.prototype.run = function(transactions, callback) {
    transactions = this.configuration.options['sorted'] ? sortTransactions(transactions) : transactions;
    async.mapSeries(transactions, this.configureTransaction, function(err, results) {
      return transactions = results;
    });
    addHooks({}, transactions);
    return async.eachSeries(transactions, this.executeTransaction, function() {
      return callback();
    });
  };

  TransactionRunner.prototype.configureTransaction = function(transaction, callback) {
    var caseInsensitiveMap, configuration, configuredTransaction, expected, flatHeaders, fullPath, header, id, key, name, origin, parsedUrl, request, response, splitHeader, system, value, _i, _len, _ref;
    configuration = this.configuration;
    origin = transaction['origin'];
    request = transaction['request'];
    response = transaction['response'];
    parsedUrl = url.parse(configuration['server']);
    if (parsedUrl['path'] === "/") {
      fullPath = request['uri'];
    } else {
      fullPath = '/' + [parsedUrl['path'].replace(/^\/|\/$/g, ""), request['uri'].replace(/^\/|\/$/g, "")].join("/");
    }
    flatHeaders = flattenHeaders(request['headers']);
    if (!flatHeaders['User-Agent']) {
      system = os.type() + ' ' + os.release() + '; ' + os.arch();
      flatHeaders['User-Agent'] = "Dredd/" + packageConfig['version'] + " (" + system + ")";
    }
    caseInsensitiveMap = {};
    for (key in flatHeaders) {
      value = flatHeaders[key];
      caseInsensitiveMap[key.toLowerCase()] = key;
    }
    if (!caseInsensitiveMap['content-length'] && request['body'] !== '') {
      flatHeaders['Content-Length'] = request['body'].length;
    }
    if (configuration.options.header.length > 0) {
      _ref = configuration.options.header;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        header = _ref[_i];
        splitHeader = header.split(':');
        flatHeaders[splitHeader[0]] = splitHeader[1];
      }
    }
    request['headers'] = flatHeaders;
    name = '';
    if (origin['resourceGroupName']) {
      name += origin['resourceGroupName'];
    }
    if (origin['resourceName']) {
      name += ' > ' + origin['resourceName'];
    }
    if (origin['actionName']) {
      name += ' > ' + origin['actionName'];
    }
    if (origin['exampleName']) {
      name += ' > ' + origin['exampleName'];
    }
    id = request['method'] + ' ' + request['uri'];
    expected = {
      headers: flattenHeaders(response['headers']),
      body: response['body'],
      statusCode: response['status']
    };
    if (response['schema']) {
      expected['bodySchema'] = response['schema'];
    }
    configuredTransaction = {
      name: name,
      id: id,
      host: parsedUrl['hostname'],
      port: parsedUrl['port'],
      request: request,
      expected: expected,
      origin: origin,
      fullPath: fullPath,
      protocol: parsedUrl.protocol
    };
    return callback(null, configuredTransaction);
  };

  TransactionRunner.prototype.executeTransaction = function(transaction, callback) {
    var buffer, configuration, handleRequest, req, requestOptions, test, transport, _ref;
    configuration = this.configuration;
    requestOptions = {
      host: transaction.host,
      port: transaction.port,
      path: transaction.fullPath,
      method: transaction.request['method'],
      headers: transaction.request.headers
    };
    test = {
      status: '',
      title: transaction.id,
      message: transaction.name,
      origin: transaction.origin
    };
    if (configuration.options.names) {
      logger.info(transaction.name);
      return callback();
    }
    configuration.emitter.emit('test start', test);
    if (configuration.options['dry-run']) {
      logger.info("Dry run, skipping API Tests...");
      return callback();
    } else if (configuration.options.method.length > 0 && !(_ref = transaction.request.method, __indexOf.call(configuration.options.method, _ref) >= 0)) {
      configuration.emitter.emit('test skip', test);
      return callback();
    } else {
      buffer = "";
      handleRequest = function(res) {
        res.on('data', function(chunk) {
          return buffer = buffer + chunk;
        });
        req.on('error', function(error) {
          if (error) {
            return configuration.emitter.emit('test error', error, test);
          }
        });
        return res.on('end', function() {
          var real;
          real = {
            statusCode: res.statusCode,
            headers: res.headers,
            body: buffer
          };
          transaction['real'] = real;
          return gavel.isValid(real, transaction.expected, 'response', function(error, isValid) {
            if (error) {
              configuration.emitter.emit('test error', error, test);
            }
            if (isValid) {
              test.status = "pass";
              test.actual = real;
              test.expected = transaction.expected;
              test.request = transaction.request;
              configuration.emitter.emit('test pass', test);
              return callback();
            } else {
              return gavel.validate(real, transaction.expected, 'response', function(error, result) {
                var data, entity, entityResult, message, _i, _len, _ref1;
                if (error) {
                  configuration.emitter.emit('test error', error, test);
                }
                message = '';
                for (entity in result) {
                  data = result[entity];
                  _ref1 = data['results'];
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    entityResult = _ref1[_i];
                    message += entity + ": " + entityResult['message'] + "\n";
                  }
                }
                test.status = "fail";
                test.title = transaction.id;
                test.message = message;
                test.actual = real;
                test.expected = transaction.expected;
                test.request = transaction.request;
                test.start = test.start;
                test.results = result;
                configuration.emitter.emit('test fail', test);
                return callback();
              });
            }
          });
        });
      };
      transport = transaction.protocol === 'https:' ? https : http;
      req = transport.request(requestOptions, handleRequest);
      if (transaction.request['body'] !== '') {
        req.write(transaction.request['body']);
      }
      return req.end();
    }
  };

  return TransactionRunner;

})();

module.exports = TransactionRunner;
