// Generated by CoffeeScript 1.6.3
var addHooks, async, glob, hooks, logger, path, proxyquire, runHook, runHooksForTransaction,
  _this = this;

path = require('path');

require('coffee-script');

proxyquire = require('proxyquire').noCallThru();

glob = require('glob');

async = require('async');

hooks = require('./hooks');

logger = require('./logger');

addHooks = function(runner, transactions) {
  var error, file, files, pattern, transaction, _i, _j, _len, _len1, _ref, _ref1,
    _this = this;
  for (_i = 0, _len = transactions.length; _i < _len; _i++) {
    transaction = transactions[_i];
    hooks.transactions[transaction.name] = transaction;
  }
  pattern = runner != null ? (_ref = runner.configuration) != null ? (_ref1 = _ref.options) != null ? _ref1.hookfiles : void 0 : void 0 : void 0;
  if (!pattern) {
    return;
  }
  files = glob.sync(pattern);
  logger.info('Found Hookfiles: ' + files);
  try {
    for (_j = 0, _len1 = files.length; _j < _len1; _j++) {
      file = files[_j];
      proxyquire(path.resolve(process.cwd(), file), {
        'hooks': hooks
      });
    }
  } catch (_error) {
    error = _error;
    logger.warn('Skipping hook loading...');
    logger.error('Error reading hook files (' + files + ')');
    logger.error('This probably means one or more of your hookfiles is invalid.');
    if (error.message != null) {
      logger.error('Message: ' + error.message);
    }
    if (error.stack != null) {
      logger.error('Stack: ' + error.stack);
    }
    return;
  }
  runner.before('executeTransaction', function(transaction, callback) {
    return runHooksForTransaction(hooks.beforeHooks[transaction.name], transaction, callback);
  });
  return runner.after('executeTransaction', function(transaction, callback) {
    return runHooksForTransaction(hooks.afterHooks[transaction.name], transaction, callback);
  });
};

runHooksForTransaction = function(hooksForTransaction, transaction, callback) {
  var runHookWithTransaction;
  if (hooksForTransaction != null) {
    logger.debug('Running hooks...');
    runHookWithTransaction = function(hook, callback) {
      return runHook(hook, transaction, callback);
    };
    return async.eachSeries(hooksForTransaction, runHookWithTransaction, function() {
      return callback();
    });
  } else {
    return callback();
  }
};

runHook = function(hook, transaction, callback) {
  var _this = this;
  if (hook.length === 1) {
    hook(transaction);
    return callback();
  } else if (hook.length === 2) {
    return hook(transaction, function() {
      return callback();
    });
  }
};

module.exports = addHooks;
